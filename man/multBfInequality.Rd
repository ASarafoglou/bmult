% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/bmult_inequalities_mult.R
\name{multBfInequality}
\alias{multBfInequality}
\title{Computes Bayes Factors For Inequality Constrained Multinomial Parameters}
\usage{
multBfInequality(samples, restrictions)
multBfInequality(samples, x=x, Hr=Hr)
multBfInequality(x=x, Hr=Hr, a=a, factor_levels=factor_levels)
}
\arguments{
\item{samples}{matrix of dimension (\code{nsamples x nparams}) with samples from truncated Dirichlet density}

\item{restrictions}{\code{list} of class \code{bmult_rl} or of class \code{bmult_rl_ineq} as returned from \code{generateRestrictionList} that encodes
inequality constraints for each independent restriction.}

\item{x}{numeric. Vector with data}

\item{Hr}{string or character. String or character vector encoding the user specified informed hypothesis. Use either specified factor_levels
or indices to refer to parameters.}

\item{a}{numeric. Vector with concentration parameters of Dirichlet distribution. Default sets all concentration parameters to 1}

\item{factor_levels}{character. Vector with category names}

\item{prior}{logical. If TRUE the function will ignore the data and sample from the prior distribution}

\item{index}{numeric. Index of current restriction. Default is 1.}

\item{maxiter}{numeric. Maximum number of iterations for the iterative updating scheme used in the bridge sampling routine.
Default is 1,000 to avoid infinite loops.}

\item{seed}{numeric. Sets the seed for version control}

\item{niter}{numeric. Vector with number of samples to be drawn from truncated distribution.}

\item{nburnin}{numeric. A single value specifying the number of burn-in samples when drawing from the truncated distribution.
Minimum number of burn-in samples is 10. Default is 5\% of the number of samples. Burn-in samples are removed automatically after the sampling.}
}
\value{
List consisting of the following elements:
\describe{
\item{\code{$eval}}{list consisting of the following elements:
\itemize{
\item \code{q11}: log posterior evaluations for posterior samples
\item \code{q12}: log proposal evaluations for posterior samples
\item \code{q21}: log posterior evaluations for samples from proposal
\item \code{q22}: log proposal evaluations for samples from proposal
}}
\item{\code{$niter}}{number of iterations of the iterative updating scheme}
\item{\code{$logml}}{estimate of log marginal likelihood}
\item{\code{$hyp}}{character vector that contains the inequality constrained hypothesis }
}
}
\description{
Computes Bayes factor for inequality constrained multinomial parameters using a bridge sampling routine.
Restricted hypothesis \eqn{H_r} states that category proportions follow a particular trend.
Alternative hypothesis \eqn{H_e} states that category proportions are free to vary.
}
\examples{
# priors
a <- c(1, 1, 1, 1)

# informed hypothesis
factor_levels <- c('theta1', 'theta2', 'theta3', 'theta4')
Hr            <- c('theta1', '<',  'theta2', '<', 'theta3', '<', 'theta4')

results_prior  <- multBfInequality(Hr=Hr, a=a, factor_levels=factor_levels, 
prior=TRUE, seed = 2020)
# corresponds to
cbind(exp(results_prior$logml), 1/factorial(4))

# alternative - if you have samples and a restriction list
inequalities  <- generateRestrictionList(Hr=Hr, a=a,
factor_levels=factor_levels)$inequality_constraints
prior_samples <- multTruncatedSampling(inequalities, niter = 1e4, 
prior=TRUE, seed = 2020)
results_prior <- multBfInequality(prior_samples, inequalities, seed=2020)
cbind(exp(results_prior$logml), 1/factorial(4))
}
\seealso{
Other functions to evaluate informed hypotheses: 
\code{\link{binomBfEquality}()},
\code{\link{binomBfInequality}()},
\code{\link{binomBfInformed}()},
\code{\link{multBfEquality}()},
\code{\link{multBfInformed}()}
}
\concept{functions to evaluate informed hypotheses}
