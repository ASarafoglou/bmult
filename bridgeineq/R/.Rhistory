x
list.files()
list.files('R/')
sapply(list.files('R/'), source)
setwd('R/')
list.files()
sapply(list.files(), source)
sapply(list.files(), source)
output_total <- multBayesInformed(factorLevels, OR, a, x, niter, options = list(bayesFactorType = 'BF10'))
a
counts
.checkAlphaAndData(alpha = a, data = counts)
alpha <- a
data <- counts
# stop function if alpha is empty or values are not numeric
if(is.null(alpha)) stop('The bridge sampling method requires the specification of alpha parameters.')
if(!is.numeric(alpha)) stop('The bridge sampling method requires the specification of alpha as numeric vector.')
!is.null(data)
# stop function if data values are not numeric
if(!is.numeric(data)) stop('The bridge sampling method requires the specification of data as numeric vector.')
length(alpha)
length(data)
sapply(list.files(), source)
output_total <- multBayesInformed(factorLevels, OR, a, x, niter, options = list(bayesFactorType = 'BF10'))
output_total <- multBayesInformed(factorLevels, OR, a, x, niter, options = list(bayesFactorType = 'BF10'))
compare
unique(compare)
sapply(list.files(), source)
output_total <- multBayesInformed(factorLevels, OR, a, x, niter, options = list(bayesFactorType = 'BF10'))
output_total <- multBayesInformed(factorLevels, OR, a, x, niter, options = list(bayesFactorType = 'BF10'))
sapply(list.files(), source)
output_total <- multBayesInformed(factorLevels, OR, a, x, niter, options = list(bayesFactorType = 'BF10'))
head(samples)
sapply(list.files(), source)
output_total <- multBayesInformed(factorLevels, OR, a, x, niter, options = list(bayesFactorType = 'BF10'))
sapply(list.files(), source)
output_total <- multBayesInformed(factorLevels, OR, a, x, niter, options = list(bayesFactorType = 'BF10'))
sapply(list.files(), source)
output_total <- multBayesInformed(factorLevels, OR, a, x, niter, options = list(bayesFactorType = 'BF10'))
class(restrictions)
sapply(list.files(), source)
output_total <- multBayesInformed(factorLevels, OR, a, x, niter, options = list(bayesFactorType = 'BF10'))
class(restrictions)
sapply(list.files(), source)
output_total <- multBayesInformed(factorLevels, OR, a, x, niter, options = list(bayesFactorType = 'BF10'))
class(out)
class(out$inequality_constraints)
sapply(list.files(), source)
output_total <- multBayesInformed(factorLevels, OR, a, x, niter, options = list(bayesFactorType = 'BF10'))
class(out)
out <- structure(out, class = 'bmult_rl')
class(out)
class(out$inequality_constraints)
out <- lapply(out, function(x) class(x, 'bmult_rl'))
length(out)
out <- lapply(out, function(x) class(x) <- 'bmult_rl'))
out <- lapply(out, function(x) class(x) <- 'bmult_rl')
class(out)
out
class(out) <- 'bmult_rl'
out
out$full_model
## Initialize Output List
out <- list(full_model             = list(hyp             = NULL,
parameters_full = NULL,
alpha_full      = NULL,
counts_full     = NULL),
equality_constraints   = list(hyp                 = NULL,
parameters_equality = NULL,
equality_hypotheses = NULL,
alpha_equalities    = NULL,
counts_equalities   = NULL),
inequality_constraints = list(hyp                   = NULL,
parameters_inequality = NULL,
inequality_hypotheses = NULL,
alpha_inequalities    = NULL,
counts_inequalities   = NULL,
nr_mult_equal         = NULL,
nr_mult_free       = NULL,
mult_equal            = NULL,
boundaries            = NULL,
nineq_per_hyp         = NULL,
direction             = NULL))
class(out)
out
# assign class
out <- lapply(out, function(x) class(x) <- 'bmult_rl')
class(out) <- 'bmult_rl'
out
out$inequality_constraints
class(out$inequality_constraints)
bubba <- list(first="one", second="two", third="third")
class(bubba) <- append(class(bubba),"bridge")
bubba
bubba <- list(first="one", second="two", third="third")
bubba
class(bubba) <- append(class(bubba),"bridge")
bubba
bubba <- list(first="one", second="two", third="third")
bubba
class(bubba) <- append(class(bubba), "bmult")
bubba
class(bubba$first)
out <- list(first="one", second="two", third="third")
class(out) <- 'bmult_rl'
out
# assign class
out <- lapply(out, function(x) append(class(x), 'bmult_rl'))
out
out$first
out <- list(first="one", second="two", third="third")
# assign class
out <- sapply(out, function(x) append(class(x), 'bmult_rl'))
out
out <- list(first="one", second="two", third="third")
out$first
class(out$first)
lapply(out, class)
lapply(out, function(x) class(x))
lapply(out, function(x) class(x) <- 'bmult')
lapply(out, function(x) class(x) <- 'bmult')
out
lapply(out, function(x) append(class(x), 'bmult_rl'))
lapply(out, function(x) append(class(x), 'bmult_rl'))$first
out
# assign class
class(out)        <-  append(class(out), 'bmult_rl')
class(out$first)  <-  append(class(out$first), 'bmult_rl')
class(out$second) <-  append(class(out$second), 'bmult_rl')
class(out$third)  <-  append(class(out$third), 'bmult_rl')
out
sapply(list.files(), source)
sapply(list.files(), source)
output_total <- multBayesInformed(factorLevels, OR, a, x, niter, options = list(bayesFactorType = 'BF10'))
str(out)
str(out$inequality_constraints)
class(out$inequality_constraints)
sapply(list.files(), source)
output_total <- multBayesInformed(factorLevels, OR, a, x, niter, options = list(bayesFactorType = 'BF10'))
sapply(list.files(), source)
output_total <- multBayesInformed(factorLevels, OR, a, x, niter, options = list(bayesFactorType = 'BF10'))
input_samples <- output_total$samples$post.samples[[1]]
inequalities  <- output_total$restrictions$inequality_constraints
class(inequalities)
input_samples <- output_total$samples$post.samples[[1]]
inequalities  <- output_total$restrictions$inequality_constraints
index         <- 1
bridge_output <- multBayesBfInequality(input_samples, inequalities, index, prior = FALSE, maxiter = 1e3)
print(bridge_output)
summary(bridge_output)
# method nr.2: (no restriction list provided)
bridge_output <- multBayesBfInequality(input_samples, OR, alpha = rep(1,ncol(samples)), data = x)
head(input_samples)
OR
# method nr.2: (no restriction list provided)
bridge_output <- multBayesBfInequality(input_samples, OR=c('g1', '>', 'g3', '>', 'g4'), data = c(0, 0, 0))
# method nr.2: (no restriction list provided)
bridge_output <- multBayesBfInequality(input_samples, restrictions=c('g1', '>', 'g3', '>', 'g4'), data = c(0, 0, 0))
#' @param maxiter maximum number of iterations for the iterative updating scheme. Default is 1,000 to avoid infinite loops.
#' @return list consisting of the following elements:
#'         (1) eval: list consisting of the following elements
#'                   q11: log posterior evaluations for posterior samples.
#'                   q12: log proposal evaluations for posterior samples.
#'                   q21: log posterior evaluations for samples from proposal.
#'                   q22: log proposal evaluations for samples from proposal.
#'         (2) niter: number of iterations of the iterative updating scheme.
#'         (3) logml: estimate of log marginal likelihood.
#' @export
multBayesBfInequality <- function(samples, restrictions, alpha = rep(1,ncol(samples)), data = NULL, prior = FALSE,
index = 1, maxiter = 1e3,... ){
###    Code by Gronau et al. (2017) - online appendix ###
###    Modified by Alexandra Sarafoglou               ###
# Note that before applying this function the user needs to:
# 1. Collect 2*N1 samples from the truncated prior and posterior distribution
#    (e.g., through MCMC sampling)
# 2. Choose a suitable proposal distribution. Here we choose the multivariate normal &
#    Specify the function for evaluating the log of the unnormalized density.
#    This function is here referred to as log_unnormalized_density.
browser()
# 0.1 Check User Input
.checksIfMatrix(samples)
## 0.2 Extract Relevant Information
# if order restriction is given as character vector, create restriction list
if(!inherits(restrictions, 'bmult_rl')){
if(!is.null(colnames(samples))){
factors_analysis <- factor_levels <- colnames(samples)
} else {
factors_analysis <- factor_levels <- paste0('theta', 1:ncol(samples))
}
restrictions     <- generateRestrictionList(restrictions, factors_analysis, factor_levels, alpha, data)
prior_and_data   <- restrictions$alpha_inequalities[[index]] + restrictions$counts_inequalities[[index]]
} else {
if(prior){
prior_and_data   <- restrictions$alpha_inequalities[[index]]
} else {
prior_and_data   <- restrictions$alpha_inequalities[[index]] + restrictions$counts_inequalities[[index]]
}
}
boundaries       <- restrictions$boundaries[[index]]
nr_mult_free     <- restrictions$nr_mult_free[[index]]
nr_mult_equal    <- restrictions$nr_mult_equal[[index]]
mult_equal       <- restrictions$mult_equal[[index]]
hyp_direction    <- restrictions$direction[index]
hyp              <- restrictions$hyp[[index]]
# check if correct number of parameters were provided
.checkNrParameters(samples = samples, boundaries = boundaries, data = prior_and_data)
# 2. Specify the function for evaluating the log of the unnormalized density
# 3. Transform the parameters to the real line
samples     <- tDirTrans(samples, boundaries, mult_equal, nr_mult_equal, nr_mult_free, hyp_direction)
# 4. Split the samples into two parts
# Use the first 50% for fiting the proposal distribution and the second 50%
# in the iterative scheme.
nperchain      <- nrow(samples)
fit_index      <- 1:(nperchain/2)
samples_4_fit  <- samples[fit_index,, drop = FALSE]
samples_4_iter <- samples[-fit_index,, drop = FALSE]
# 5. Fit proposal distribution
N2 <- N1 <- nrow(samples_4_iter)
m  <- apply(samples_4_fit, 2, mean) # mean vector
V  <- cov(samples_4_fit)            # covariance matrix
# 6. Draw N2 samples from the proposal distribution
gen_samples <- mvtnorm::rmvnorm(N2, m, V)
# 7a. Evaluate proposal distribution for posterior & generated samples
q12 <- mvtnorm::dmvnorm(samples_4_iter, m, V, log = TRUE)
q22 <- mvtnorm::dmvnorm(gen_samples   , m, V, log = TRUE)
# 7b. Evaluate unnormalized posterior for posterior & generated samples
q11 <- logUnnormalizedTDir(samples_4_iter, boundaries, mult_equal, nr_mult_equal, nr_mult_free, hyp_direction, prior_and_data)
q21 <- logUnnormalizedTDir(gen_samples   , boundaries, mult_equal, nr_mult_equal, nr_mult_free, hyp_direction, prior_and_data)
# 8. Run iterative scheme as proposed in Meng and Wong (1996) to estimate
# the marginal likelihood
l1 <- q11 - q12
l2 <- q21 - q22
# increase numerical stability by subtracting the median of l1 from l1 & l2
lstar <- median(l1)
s1    <- N1/(N1 + N2)
s2    <- N2/(N1 + N2)
e     <- Brobdingnag::as.brob( exp(1) )     # more stable Brobdingnag number representation
criterion_val <- 1e-10 + 1 # criterion value
r <- 0                     # starting value for r
i <- 0                     # iteration counter
while (criterion_val > 1e-10 & i < maxiter) {
r_old <- r
numerator <- as.numeric(e^(l2 - lstar)/(s1 * e^(l2 - lstar) + s2 *  r))
denominator <- as.numeric(1/(s1 * e^(l1 - lstar) + s2 * r))
r <- (N1/N2)*sum(numerator)/sum(denominator)
i <- i + 1
criterion_val <- abs((r - r_old)/r)
}
logml <- log(r) + lstar # log of marginal likelihood
# Return a list with the evaluations of the proposal and the unnormalized
# posterior, the number of iterations of the iterative scheme, and the
# estimated log marginal likelihood
output <- list(eval  = list(q11 = q11, q12 = q12,
q21 = q21, q22 = q22),
niter = i, logml = logml, hyp = hyp)
# Compute error measures for estimated marginal likelihood
error_measures        <- .computeRMSE(output)
output$error_measures <- error_measures
# assign class
class(output) <- 'bmult_bridge'
return(output)
}
# method nr.2: (no restriction list provided)
bridge_output <- multBayesBfInequality(input_samples, restrictions=c('g1', '>', 'g3', '>', 'g4'), data = c(0, 0, 0))
restrictions
factors_analysis
alpha
data
restrictions$alpha_inequalities[[index]]
restrictions$counts_inequalities[[index]]
str(restrictions)
#' @param maxiter maximum number of iterations for the iterative updating scheme. Default is 1,000 to avoid infinite loops.
#' @return list consisting of the following elements:
#'         (1) eval: list consisting of the following elements
#'                   q11: log posterior evaluations for posterior samples.
#'                   q12: log proposal evaluations for posterior samples.
#'                   q21: log posterior evaluations for samples from proposal.
#'                   q22: log proposal evaluations for samples from proposal.
#'         (2) niter: number of iterations of the iterative updating scheme.
#'         (3) logml: estimate of log marginal likelihood.
#' @export
multBayesBfInequality <- function(samples, restrictions, alpha = rep(1,ncol(samples)), data = NULL, prior = FALSE,
index = 1, maxiter = 1e3,... ){
###    Code by Gronau et al. (2017) - online appendix ###
###    Modified by Alexandra Sarafoglou               ###
# Note that before applying this function the user needs to:
# 1. Collect 2*N1 samples from the truncated prior and posterior distribution
#    (e.g., through MCMC sampling)
# 2. Choose a suitable proposal distribution. Here we choose the multivariate normal &
#    Specify the function for evaluating the log of the unnormalized density.
#    This function is here referred to as log_unnormalized_density.
browser()
# 0.1 Check User Input
.checksIfMatrix(samples)
## 0.2 Extract Relevant Information
# if order restriction is given as character vector, create restriction list
if(!inherits(restrictions, 'bmult_rl')){
if(!is.null(colnames(samples))){
factors_analysis <- factor_levels <- colnames(samples)
} else {
factors_analysis <- factor_levels <- paste0('theta', 1:ncol(samples))
}
restriction_list     <- generateRestrictionList(restrictions, factors_analysis, factor_levels, alpha, data)
restrctions          <- restriction_list$inequality_constraints
prior_and_data       <- restrictions$alpha_inequalities[[index]] + restrictions$counts_inequalities[[index]]
} else {
if(prior){
prior_and_data   <- restrictions$alpha_inequalities[[index]]
} else {
prior_and_data   <- restrictions$alpha_inequalities[[index]] + restrictions$counts_inequalities[[index]]
}
}
boundaries       <- restrictions$boundaries[[index]]
nr_mult_free     <- restrictions$nr_mult_free[[index]]
nr_mult_equal    <- restrictions$nr_mult_equal[[index]]
mult_equal       <- restrictions$mult_equal[[index]]
hyp_direction    <- restrictions$direction[index]
hyp              <- restrictions$hyp[[index]]
# check if correct number of parameters were provided
.checkNrParameters(samples = samples, boundaries = boundaries, data = prior_and_data)
# 2. Specify the function for evaluating the log of the unnormalized density
# 3. Transform the parameters to the real line
samples     <- tDirTrans(samples, boundaries, mult_equal, nr_mult_equal, nr_mult_free, hyp_direction)
# 4. Split the samples into two parts
# Use the first 50% for fiting the proposal distribution and the second 50%
# in the iterative scheme.
nperchain      <- nrow(samples)
fit_index      <- 1:(nperchain/2)
samples_4_fit  <- samples[fit_index,, drop = FALSE]
samples_4_iter <- samples[-fit_index,, drop = FALSE]
# 5. Fit proposal distribution
N2 <- N1 <- nrow(samples_4_iter)
m  <- apply(samples_4_fit, 2, mean) # mean vector
V  <- cov(samples_4_fit)            # covariance matrix
# 6. Draw N2 samples from the proposal distribution
gen_samples <- mvtnorm::rmvnorm(N2, m, V)
# 7a. Evaluate proposal distribution for posterior & generated samples
q12 <- mvtnorm::dmvnorm(samples_4_iter, m, V, log = TRUE)
q22 <- mvtnorm::dmvnorm(gen_samples   , m, V, log = TRUE)
# 7b. Evaluate unnormalized posterior for posterior & generated samples
q11 <- logUnnormalizedTDir(samples_4_iter, boundaries, mult_equal, nr_mult_equal, nr_mult_free, hyp_direction, prior_and_data)
q21 <- logUnnormalizedTDir(gen_samples   , boundaries, mult_equal, nr_mult_equal, nr_mult_free, hyp_direction, prior_and_data)
# 8. Run iterative scheme as proposed in Meng and Wong (1996) to estimate
# the marginal likelihood
l1 <- q11 - q12
l2 <- q21 - q22
# increase numerical stability by subtracting the median of l1 from l1 & l2
lstar <- median(l1)
s1    <- N1/(N1 + N2)
s2    <- N2/(N1 + N2)
e     <- Brobdingnag::as.brob( exp(1) )     # more stable Brobdingnag number representation
criterion_val <- 1e-10 + 1 # criterion value
r <- 0                     # starting value for r
i <- 0                     # iteration counter
while (criterion_val > 1e-10 & i < maxiter) {
r_old <- r
numerator <- as.numeric(e^(l2 - lstar)/(s1 * e^(l2 - lstar) + s2 *  r))
denominator <- as.numeric(1/(s1 * e^(l1 - lstar) + s2 * r))
r <- (N1/N2)*sum(numerator)/sum(denominator)
i <- i + 1
criterion_val <- abs((r - r_old)/r)
}
logml <- log(r) + lstar # log of marginal likelihood
# Return a list with the evaluations of the proposal and the unnormalized
# posterior, the number of iterations of the iterative scheme, and the
# estimated log marginal likelihood
output <- list(eval  = list(q11 = q11, q12 = q12,
q21 = q21, q22 = q22),
niter = i, logml = logml, hyp = hyp)
# Compute error measures for estimated marginal likelihood
error_measures        <- .computeRMSE(output)
output$error_measures <- error_measures
# assign class
class(output) <- 'bmult_bridge'
return(output)
}
# method nr.2: (no restriction list provided)
bridge_output <- multBayesBfInequality(input_samples, restrictions=c('g1', '>', 'g3', '>', 'g4'), data = c(0, 0, 0))
#' @param maxiter maximum number of iterations for the iterative updating scheme. Default is 1,000 to avoid infinite loops.
#' @return list consisting of the following elements:
#'         (1) eval: list consisting of the following elements
#'                   q11: log posterior evaluations for posterior samples.
#'                   q12: log proposal evaluations for posterior samples.
#'                   q21: log posterior evaluations for samples from proposal.
#'                   q22: log proposal evaluations for samples from proposal.
#'         (2) niter: number of iterations of the iterative updating scheme.
#'         (3) logml: estimate of log marginal likelihood.
#' @export
multBayesBfInequality <- function(samples, restrictions, alpha = rep(1,ncol(samples)), data = NULL, prior = FALSE,
index = 1, maxiter = 1e3,... ){
###    Code by Gronau et al. (2017) - online appendix ###
###    Modified by Alexandra Sarafoglou               ###
# Note that before applying this function the user needs to:
# 1. Collect 2*N1 samples from the truncated prior and posterior distribution
#    (e.g., through MCMC sampling)
# 2. Choose a suitable proposal distribution. Here we choose the multivariate normal &
#    Specify the function for evaluating the log of the unnormalized density.
#    This function is here referred to as log_unnormalized_density.
browser()
# 0.1 Check User Input
.checksIfMatrix(samples)
## 0.2 Extract Relevant Information
# if order restriction is given as character vector, create restriction list
if(!inherits(restrictions, 'bmult_rl')){
if(!is.null(colnames(samples))){
factors_analysis <- factor_levels <- colnames(samples)
} else {
factors_analysis <- factor_levels <- paste0('theta', 1:ncol(samples))
}
restriction_list     <- generateRestrictionList(restrictions, factors_analysis, factor_levels, alpha, data)
# only consider inequality constraints
restrictions          <- restriction_list$inequality_constraints
prior_and_data       <- restrictions$alpha_inequalities[[index]] + restrictions$counts_inequalities[[index]]
} else {
if(prior){
prior_and_data   <- restrictions$alpha_inequalities[[index]]
} else {
prior_and_data   <- restrictions$alpha_inequalities[[index]] + restrictions$counts_inequalities[[index]]
}
}
boundaries       <- restrictions$boundaries[[index]]
nr_mult_free     <- restrictions$nr_mult_free[[index]]
nr_mult_equal    <- restrictions$nr_mult_equal[[index]]
mult_equal       <- restrictions$mult_equal[[index]]
hyp_direction    <- restrictions$direction[index]
hyp              <- restrictions$hyp[[index]]
# check if correct number of parameters were provided
.checkNrParameters(samples = samples, boundaries = boundaries, data = prior_and_data)
# 2. Specify the function for evaluating the log of the unnormalized density
# 3. Transform the parameters to the real line
samples     <- tDirTrans(samples, boundaries, mult_equal, nr_mult_equal, nr_mult_free, hyp_direction)
# 4. Split the samples into two parts
# Use the first 50% for fiting the proposal distribution and the second 50%
# in the iterative scheme.
nperchain      <- nrow(samples)
fit_index      <- 1:(nperchain/2)
samples_4_fit  <- samples[fit_index,, drop = FALSE]
samples_4_iter <- samples[-fit_index,, drop = FALSE]
# 5. Fit proposal distribution
N2 <- N1 <- nrow(samples_4_iter)
m  <- apply(samples_4_fit, 2, mean) # mean vector
V  <- cov(samples_4_fit)            # covariance matrix
# 6. Draw N2 samples from the proposal distribution
gen_samples <- mvtnorm::rmvnorm(N2, m, V)
# 7a. Evaluate proposal distribution for posterior & generated samples
q12 <- mvtnorm::dmvnorm(samples_4_iter, m, V, log = TRUE)
q22 <- mvtnorm::dmvnorm(gen_samples   , m, V, log = TRUE)
# 7b. Evaluate unnormalized posterior for posterior & generated samples
q11 <- logUnnormalizedTDir(samples_4_iter, boundaries, mult_equal, nr_mult_equal, nr_mult_free, hyp_direction, prior_and_data)
q21 <- logUnnormalizedTDir(gen_samples   , boundaries, mult_equal, nr_mult_equal, nr_mult_free, hyp_direction, prior_and_data)
# 8. Run iterative scheme as proposed in Meng and Wong (1996) to estimate
# the marginal likelihood
l1 <- q11 - q12
l2 <- q21 - q22
# increase numerical stability by subtracting the median of l1 from l1 & l2
lstar <- median(l1)
s1    <- N1/(N1 + N2)
s2    <- N2/(N1 + N2)
e     <- Brobdingnag::as.brob( exp(1) )     # more stable Brobdingnag number representation
criterion_val <- 1e-10 + 1 # criterion value
r <- 0                     # starting value for r
i <- 0                     # iteration counter
while (criterion_val > 1e-10 & i < maxiter) {
r_old <- r
numerator <- as.numeric(e^(l2 - lstar)/(s1 * e^(l2 - lstar) + s2 *  r))
denominator <- as.numeric(1/(s1 * e^(l1 - lstar) + s2 * r))
r <- (N1/N2)*sum(numerator)/sum(denominator)
i <- i + 1
criterion_val <- abs((r - r_old)/r)
}
logml <- log(r) + lstar # log of marginal likelihood
# Return a list with the evaluations of the proposal and the unnormalized
# posterior, the number of iterations of the iterative scheme, and the
# estimated log marginal likelihood
output <- list(eval  = list(q11 = q11, q12 = q12,
q21 = q21, q22 = q22),
niter = i, logml = logml, hyp = hyp)
# Compute error measures for estimated marginal likelihood
error_measures        <- .computeRMSE(output)
output$error_measures <- error_measures
# assign class
class(output) <- 'bmult_bridge'
return(output)
}
# method nr.2: (no restriction list provided)
bridge_output <- multBayesBfInequality(input_samples, restrictions=c('g1', '>', 'g3', '>', 'g4'), data = c(0, 0, 0))
print(bridge_output)
#' print method for class \code{bmult_bridge}
#'
#' @param x object of class \code{bmult_bridge} as returned from \code{multBayesBfInequality}
#' @param ... further arguments, currently ignored
#' @return The print methods print the results and return nothing
#' @export
print.bmult_bridge <- function(x, ...){
logml <- round(x$logml,5)
hyp   <- paste(x$hyp, collapse=" ")
niter <- x$niter
error <- x$error_measures$percentage
res <- paste('Bridge sampling estimate of the log marginal likelihood:', logml,
'\n\nHypothesis:\n\n', hyp,
'\n\nEstimate obtained in', niter, 'iteration(s).',
'\nPercentage Error:', error, sep = ' ')
cat(res)
}
print(bridge_output)
summary(bridge_output)
sapply(list.files(), source)
# method nr.2: (no restriction list provided)
bridge_output <- multBayesBfInequality(input_samples, restrictions=c('g1', '>', 'g3', '>', 'g4'), data = c(0, 0, 0))
# method nr.1: (provides full restriction list)
bridge_output <- multBayesBfInequality(input_samples, restrictions=output_total$restrictions)
bridge_output
