obeys_lower <- rowSums(samples[, i] < samples[, boundaries[[i]]$lower,  drop = FALSE]) > 0
pb$tick()
obeys_upper <- rowSums(samples[, i] > samples[, boundaries[[i]]$upper,  drop = FALSE]) > 0
pb$tick()
I_mat[, i]  <- obeys_lower & obeys_upper
}
for(i in 1:N){
obeys_lower <- rowSums(samples[, i] < samples[, boundaries[[i]]$lower,  drop = FALSE]) > 0
#pb$tick()
obeys_upper <- rowSums(samples[, i] > samples[, boundaries[[i]]$upper,  drop = FALSE]) > 0
#pb$tick()
I_mat[, i]  <- obeys_lower & obeys_upper
}
I_mat    <- matrix(NA, nrow = nsamples, ncol = N)
I_mat    <- matrix(NA, nrow = nrow(samples), ncol = N)
for(i in 1:N){
obeys_lower <- rowSums(samples[, i] < samples[, boundaries[[i]]$lower,  drop = FALSE]) > 0
#pb$tick()
obeys_upper <- rowSums(samples[, i] > samples[, boundaries[[i]]$upper,  drop = FALSE]) > 0
#pb$tick()
I_mat[, i]  <- obeys_lower & obeys_upper
}
length(boundaries)
boundaries <- out$restrictions$inequality_constraints$boundaries[[1]]
I_mat    <- matrix(NA, nrow = nsamples, ncol = N)
for(i in 1:N){
obeys_lower <- rowSums(samples[, i] < samples[, boundaries[[i]]$lower,  drop = FALSE]) > 0
#pb$tick()
obeys_upper <- rowSums(samples[, i] > samples[, boundaries[[i]]$upper,  drop = FALSE]) > 0
#pb$tick()
I_mat[, i]  <- obeys_lower & obeys_upper
}
head(I_mat)
mean(rowSums(I_mat) == N)
log(I)
log(mean(rowSums(I_mat) == N))
samples <- out$samples$post.samples[[1]]
for(i in 1:N){
obeys_lower <- rowSums(samples[, i] < samples[, boundaries[[i]]$lower,  drop = FALSE]) > 0
pb$tick()
obeys_upper <- rowSums(samples[, i] > samples[, boundaries[[i]]$upper,  drop = FALSE]) > 0
pb$tick()
I_mat[, i]  <- obeys_lower & obeys_upper
}
for(i in 1:N){
obeys_lower <- rowSums(samples[, i] < samples[, boundaries[[i]]$lower,  drop = FALSE]) > 0
#pb$tick()
obeys_upper <- rowSums(samples[, i] > samples[, boundaries[[i]]$upper,  drop = FALSE]) > 0
#pb$tick()
I_mat[, i]  <- obeys_lower & obeys_upper
}
I <- mean(rowSums(I_mat) == N)
I
log(I)
I- I
devtools::install()
out <- binomBayesInformed(factor_levels, Hr2, a=a, b=b, counts=counts, total=total, niter = 5e6, bf_type = 'LogBFer'); out
logml_prior
logml_post
logBFer
logBFe_inequalities
logml_prior
logml_prior - logml_post
-Inf - logml_post
-Inf - -Inf
-Inf - 4
4 - -Inf
is.infinite(-Inf)
?is.infinite
logml_prior <- iInf
logml_prior <- -Inf
logml_post <- -Inf
logml_prior - logml_post
-Inf - Inf
(logml_prior == Inf & logml_post == Inf || logml_prior == -Inf & -logml_post)
(logml_prior == Inf & logml_post == Inf )
|| logml_prior == -Inf & -logml_post
|| logml_prior == -Inf & -logml_post
logml_prior == -Inf & -logml_post
# devtools::create("bridgeineq")
# devtools::use_rcpp()
devtools::document()
devtools::install()
out <- binomBayesInformed(factor_levels, Hr, a, b, counts, total, niter = 5e6, bf_type = 'LogBFer', seed=2020)
truncatedSamplingSubiterationBinomialCDF(runif(1), 1, 0, 1)
truncatedSamplingSubiterationBinomialY(runif(1), 0.5, 0)
truncatedSamplingSubiterationBinomialY(runif(1), 0.5, 3)
?rbeta
a <- c(1, 1, 1, 1)
b <- c(1, 1, 1, 1)
K = length(a)
rbeta(K, a, b)
z <- rbeta(K, a, b)
y <- runif(K)
k = 1
1/(b[k]
)
(1/(b[k]))
y[k]^(1/(b[k])))
y[k]^(1/(b[k]))
1 - y[k]^(1/(b[k]))
1/30000
0.5^(1/30000)
0.99^(1/30000)
0.0001^(1/30000)
# devtools::create("bridgeineq")
# devtools::use_rcpp()
devtools::document()
devtools::install()
factor_levels <- c('binom1', 'binom2', 'binom3', 'binom4')
counts        <- c(3, 4, 10, 11)
total         <- c(15, 12, 12, 12)
a             <- c(1, 1, 1, 1)
b             <- c(1, 1, 1, 1)
Hr            <- c('binom1 < binom2 < binom3 < binom4')
out <- binomBayesInformed(factor_levels, Hr, a, b, counts, total, niter = 5e6, bf_type = 'LogBFer', seed=2020)
inequalities <- out$restrictions$inequality_constraints$boundaries
class(inequalities)
class(out$restrictions$inequality_constraints)
inequalities <- out$restrictions$inequality_constraints
samples <- binomTruncatedSampling(inequalities  , index=1, niter = 1e5, prior=FALSE, nburnin = niter*.05, seed=NULL)
samples <- binomTruncatedSampling(inequalities  , index=1)
# devtools::create("bridgeineq")
# devtools::use_rcpp()
devtools::document()
devtools::install()
out <- binomBayesInformed(factor_levels, Hr, a, b, counts, total, niter = 5e6, bf_type = 'LogBFer', seed=2020)
inequalities <- out$restrictions$inequality_constraints
samples <- binomTruncatedSampling(inequalities  , index=1)
devtools::install()
samples <- binomTruncatedSampling(inequalities  , index=1)
devtools::install()
samples <- binomTruncatedSampling(inequalities  , index=1)
head(samples)
Hr
s1 <- binomTruncatedSampling(inequalities  , index=1)
s2 <- out$samples$post.samples
# only keep the samples in s2 that obey the constraint
keep <- apply(s2, 1, !is.unsorted)
# only keep the samples in s2 that obey the constraint
keep <- apply(s2, 1, function(x) !is.unsorted(x))
dim(s2)
s2 <- out$samples$post.samples[[1]]
# only keep the samples in s2 that obey the constraint
keep <- apply(s2, 1, function(x) !is.unsorted(x))
s2 <- s2[keep, ]
dim(s1)
dim(s2)
colMeans(s1)
colMeans(s2)
counts/total
s1 <- binomTruncatedSampling(inequalities  , index=1, prior=TRUE)
s2 <- out$samples$prior.samples[[1]]
# only keep the samples in s2 that obey the constraint
keep <- apply(s2, 1, function(x) !is.unsorted(x))
s2 <- s2[keep, ]
colMeans(s2)
counts        <- c(0, 0, 0, 0)
total         <- c(0, 0, 0, 0)
a             <- c(1, 1, 1, 1)
b             <- c(1, 1, 1, 1)
Hr            <- c('binom1 < binom2 < binom3 < binom4')
out <- binomBayesInformed(factor_levels, Hr, a, b, counts, total, niter = 5e6, bf_type = 'LogBFer', seed=2020)
s2 <- out$samples$post.samples[[1]]
# only keep the samples in s2 that obey the constraint
keep <- apply(s2, 1, function(x) !is.unsorted(x))
s2 <- s2[keep, ]
colMeans(s2)
colMeans(s1)
plot(1:nrow(s1), s1[,1])
plot(1:nrow(s1), s1[,1], type = 'l')
par(mfrow(c(4, 1)))
par(mfrow=c(4, 1))
plot(1:nrow(s1), s1[,1], type = 'l')
plot(1:nrow(s1), s1[,2], type = 'l')
plot(1:nrow(s1), s1[,3], type = 'l')
plot(1:nrow(s1), s1[,4], type = 'l')
factor_levels <- c('binom1', 'binom2')
counts        <- c(0, 0)
total         <- c(0, 0)
a             <- c(1, 1)
b             <- c(1, 1)
Hr            <- c('binom1 < binom2')
out <- binomBayesInformed(factor_levels, Hr, a, b, counts, total, niter = 5e6, bf_type = 'LogBFer', seed=2020)
inequalities <- out$restrictions$inequality_constraints
s1 <- binomTruncatedSampling(inequalities  , index=1, prior=TRUE)
s2 <- out$samples$post.samples[[1]]
# only keep the samples in s2 that obey the constraint
keep <- apply(s2, 1, function(x) !is.unsorted(x))
s2 <- s2[keep, ]
colMeans(s2)
colMeans(s1)
devtools::install()
factor_levels <- c('binom1', 'binom2')
counts        <- c(0, 0)
total         <- c(0, 0)
a             <- c(1, 1)
b             <- c(1, 1)
Hr            <- c('binom1 < binom2')
out <- binomBayesInformed(factor_levels, Hr, a, b, counts, total, niter = 1e5, bf_type = 'LogBFer', seed=2020)
inequalities <- out$restrictions$inequality_constraints
s1 <- binomTruncatedSampling(inequalities  , index=1, prior=TRUE)
s2 <- out$samples$post.samples[[1]]
# only keep the samples in s2 that obey the constraint
keep <- apply(s2, 1, function(x) !is.unsorted(x))
s2 <- s2[keep, ]
colMeans(s2)
colMeans(s1)
factor_levels <- c('binom1', 'binom2', 'binom3', 'binom4')
counts        <- c(0, 0, 0, 0)
total         <- c(0, 0, 0, 0)
a             <- c(1, 1, 1, 1)
b             <- c(1, 1, 1, 1)
Hr            <- c('binom1 < binom2 < binom3 < binom4')
out <- binomBayesInformed(factor_levels, Hr, a, b, counts, total, niter = 3e5, bf_type = 'LogBFer', seed=2020)
inequalities <- out$restrictions$inequality_constraints
s1 <- binomTruncatedSampling(inequalities  , index=1, prior=TRUE)
s2 <- out$samples$post.samples[[1]]
# only keep the samples in s2 that obey the constraint
keep <- apply(s2, 1, function(x) !is.unsorted(x))
s2 <- s2[keep, ]
colMeans(s2)
colMeans(s1)
head(colMeans(s1))
head(s1)
head(s2)
colMeans(s2)
colMeans(s1)
head(s1)
# if order restriction is given as character vector, create restriction list
if(inherits(inequalities, 'bmult_rl') | inherits(inequalities, 'bmult_rl_ineq')){
if(inherits(inequalities, 'bmult_rl')){
inequalities  <- inequalities$inequality_constraints
}
} else {
stop('Provide a valid restriction list. The restriction list needs to be an object of class bmult_rl or bmult_rl_ineq as returned from generateRestrictionList.')
}
prior = TRUE
# extract relevant information
if(prior){
a  <- inequalities$alpha_inequalities[[index]]
b  <- inequalities$beta_inequalities[[index]]
} else {
a <- inequalities$alpha_inequalities[[index]] + inequalities$counts_inequalities[[index]]
b <- inequalities$beta_inequalities[[index]] + (inequalities$total_inequalities[[index]] - inequalities$counts_inequalities[[index]])
}
index = 1
# extract relevant information
if(prior){
a  <- inequalities$alpha_inequalities[[index]]
b  <- inequalities$beta_inequalities[[index]]
} else {
a <- inequalities$alpha_inequalities[[index]] + inequalities$counts_inequalities[[index]]
b <- inequalities$beta_inequalities[[index]] + (inequalities$total_inequalities[[index]] - inequalities$counts_inequalities[[index]])
}
a
b
boundaries      <- inequalities$boundaries[[index]]
boundaries
# logical evaluations
bounds_per_restriction       <- sapply(boundaries, function(x) is.null(x))
lower_bounds_per_restriction <- sapply(boundaries, function(x) length(x$lower) != 0)
lower_bounds_per_restriction
upper_bounds_per_restriction <- sapply(boundaries, function(x) length(x$upper) != 0)
upper_bounds_per_restriction
K        <- length(a)
niter = 20
nburnin = 10
# define 5% of samples as burn-in; minimum number of burn-in samples is 10
nburnin  <- max(c(10, nburnin))
K        <- length(a)
post_samples <- matrix(ncol=K, nrow = (niter + nburnin))
# starting values of Gibbs Sampler
theta <- rbeta(K, a, b)
theta
iteration <- 0
iter = 1
k = 1
# update latent variable
y[k]            <- truncatedSamplingSubiterationBinomialY(runif(1), theta[k], b[k] - 1)
a
b
exponent        <-  1/(b[k] - 1)
latent_variable <-  1 - (y[k]^exponent)
exponent
1/(b[k] - 1)
# check for bounds
there_are_no_bounds <- bounds_per_restriction[k]
there_are_no_bounds
# initialize bounds
lower_bound <- 0
upper_bound <- 1
# check for lower bound
there_is_a_lower_bound <- lower_bounds_per_restriction[k]
there_is_a_lower_bound
# check for upper bound
there_is_a_upper_bound <- upper_bounds_per_restriction[k]
there_is_a_upper_bound
theta[boundaries[[k]]$upper]
max(theta[boundaries[[k]]$upper])
devtools::install()
inequalities <- out$restrictions$inequality_constraints
s1 <- binomTruncatedSampling(inequalities  , index=1, prior=TRUE)
colMeans(s1)
colMeans(s2)
factor_levels <- c('binom1', 'binom2', 'binom3', 'binom4')
counts        <- c(3, 6, 14, 30)
total         <- c(15, 20, 20, 35)
a             <- c(1, 1, 1, 1)
b             <- c(1, 1, 1, 1)
Hr            <- c('binom1 < binom2 < binom3 < binom4')
out <- binomBayesInformed(factor_levels, Hr, a, b, counts, total, niter = 3e5, bf_type = 'LogBFer', seed=2020)
inequalities <- out$restrictions$inequality_constraints
s1 <- binomTruncatedSampling(inequalities  , index=1, prior=FALSE)
s2 <- out$samples$post.samples[[1]]
# only keep the samples in s2 that obey the constraint
keep <- apply(s2, 1, function(x) !is.unsorted(x))
s2 <- s2[keep, ]
colMeans(s1)
colMeans(s2)
head(s1)
devtools::install()
s1 <- binomTruncatedSampling(inequalities  , index=1, prior=FALSE)
devtools::install()
s1 <- binomTruncatedSampling(inequalities  , index=1, prior=FALSE)
s2 <- out$samples$post.samples[[1]]
colMeans(s1)
colMeans(s2)
data("journals")
counts        <- c(1, 6, 14, 340)
total         <- c(10, 20, 20, 350)
a             <- c(1, 1, 1, 1)
b             <- c(1, 1, 1, 1)
Hr            <- c('binom1 < binom2 < binom3 < binom4')
out <- binomBayesInformed(factor_levels, Hr, a, b, counts, total, niter = 3e5, bf_type = 'LogBFer', seed=2020)
inequalities <- out$restrictions$inequality_constraints
s1 <- binomTruncatedSampling(inequalities  , index=1, prior=FALSE)
s2 <- out$samples$post.samples[[1]]
# only keep the samples in s2 that obey the constraint
keep <- apply(s2, 1, function(x) !is.unsorted(x))
s2 <- s2[keep, ]
colMeans(s1)
colMeans(s2)
# devtools::create("bridgeineq")
# devtools::use_rcpp()
devtools::document()
devtools::install()
factor_levels <- c('binom1', 'binom2', 'binom3', 'binom4')
counts        <- c(1, 6, 14, 340)
total         <- c(10, 20, 20, 350)
a             <- c(1, 1, 1, 1)
b             <- c(1, 1, 1, 1)
Hr            <- c('binom1 < binom2 < binom3 < binom4')
out <- binomBayesInformed(factor_levels, Hr, a, b, counts, total, niter = 3e5, bf_type = 'LogBFer', seed=2020)
out <- binomBayesInformed(factor_levels, Hr, a, b, counts, total, niter = 3e4, bf_type = 'LogBFer', seed=2020)
# devtools::create("bridgeineq")
# devtools::use_rcpp()
devtools::document()
devtools::install()
factor_levels <- c('binom1', 'binom2', 'binom3', 'binom4')
counts        <- c(1, 6, 14, 340)
total         <- c(10, 20, 20, 350)
a             <- c(1, 1, 1, 1)
b             <- c(1, 1, 1, 1)
Hr            <- c('binom1 < binom2 < binom3 < binom4')
out <- binomBayesInformed(factor_levels, Hr, a, b, counts, total, niter = 3e4, bf_type = 'LogBFer', seed=2020)
# Create the R package "bridgeineq"
setwd("~/Git_projects/bmult/bridgeineq")
# devtools::create("bridgeineq")
# devtools::use_rcpp()
devtools::document()
devtools::install()
out <- binomBayesInformed(factor_levels, Hr, a, b, counts, total, niter = 5e3, bf_type = 'LogBFer', seed=2020)
rstudioapi::getSourceEditorContext()$path
rstudioapi::getSourceEditorContext()$path
rstudioapi::getSourceEditorContext()$path
rstudioapi::getSourceEditorContext()$path
# devtools::create("bridgeineq")
# devtools::use_rcpp()
devtools::document()
getwd()
devtools::install()
out <- binomBayesInformed(factor_levels, Hr, a, b, counts, total, niter = 5e3, bf_type = 'LogBFer', seed=2020)
# devtools::create("bridgeineq")
# devtools::use_rcpp()
devtools::document()
devtools::install()
out <- binomBayesInformed(factor_levels, Hr, a, b, counts, total, niter = 5e3, bf_type = 'LogBFer', seed=2020)
# devtools::create("bridgeineq")
# devtools::use_rcpp()
devtools::document()
devtools::install()
out <- binomBayesInformed(factor_levels, Hr, a, b, counts, total, niter = 5e3, bf_type = 'LogBFer', seed=2020)
devtools::install()
out <- binomBayesInformed(factor_levels, Hr, a, b, counts, total, niter = 5e3, bf_type = 'LogBFer', seed=2020)
devtools::install()
out <- binomBayesInformed(factor_levels, Hr, a, b, counts, total, niter = 5e3, bf_type = 'LogBFer', seed=2020)
head(theta_mat)
# devtools::create("bridgeineq")
# devtools::use_rcpp()
devtools::document()
devtools::install()
out <- binomBayesInformed(factor_levels, Hr, a, b, counts, total, niter = 5e3, bf_type = 'LogBFer', seed=2020)
head(theta_mat)
head(lower_mat)
head(upper_mat)
out <- binomBayesInformed(factor_levels, Hr, a, b, counts, total, niter = 5e3, bf_type = 'LogBFer', seed=2020)
head(logJ_vec)
length(logJ_vec)
length(logBeta_vec)
length(logposterior_vec)
length(logposterior_vec)
devtools::install()
out <- binomBayesInformed(factor_levels, Hr, a, b, counts, total, niter = 5e3, bf_type = 'LogBFer', seed=2020)
length(q12)
length(q22)
length(q11)
length(q21)
devtools::install()
out <- binomBayesInformed(factor_levels, Hr, a, b, counts, total, niter = 5e3, bf_type = 'LogBFer', seed=2020)
logml_post
devtools::install()
out <- binomBayesInformed(factor_levels, Hr, a, b, counts, total, niter = 5e3, bf_type = 'LogBFer', seed=2020)
# devtools::create("bridgeineq")
# devtools::use_rcpp()
devtools::document()
devtools::install()
out <- binomBayesInformed(factor_levels, Hr, a, b, counts, total, niter = 5e3, bf_type = 'LogBFer', seed=2020)
devtools::install()
out <- binomBayesInformed(factor_levels, Hr, a, b, counts, total, niter = 5e3, bf_type = 'LogBFer', seed=2020)
devtools::install()
out <- binomBayesInformed(factor_levels, Hr, a, b, counts, total, niter = 5e3, bf_type = 'LogBFer', seed=2020)
out
data(journals)
# Prior specification
# We assign a uniform Beta distribution on each binomial probability
a <- rep(1, 8)
b <- rep(1, 8)
counts <- journals$errors
total  <- journals$nr_NHST
factor_levels <- levels(journals$journal)
# restricted hypothesis
Hr1 <- c('JCCP < DP < JPSP')
Hr2 <- c('JAP , PS , JCCP , PLOS , DP , FP , JEPG < JPSP')
Hr3 <- c('JAP < PS < JCCP < PLOS < DP < FP < JEPG < JPSP')
out <- binomBayesInformed(factor_levels, Hr1, a=a, b=b, counts=counts, total=total, niter = 5e3, bf_type = 'LogBFer'); out
factor_levels
data(journals)
data(journals)
# Prior specification
# We assign a uniform Beta distribution on each binomial probability
a <- rep(1, 8)
b <- rep(1, 8)
counts <- journals$errors
total  <- journals$nr_NHST
factor_levels <- levels(journals$journal)
# restricted hypothesis
Hr1 <- c('JCCP < DP < JPSP')
Hr2 <- c('JAP , PS , JCCP , PLOS , DP , FP , JEPG < JPSP')
Hr3 <- c('JAP < PS < JCCP < PLOS < DP < FP < JEPG < JPSP')
out <- binomBayesInformed(factor_levels, Hr1, a=a, b=b, counts=counts, total=total, niter = 5e3, bf_type = 'LogBFer'); out
factor_levels
journals
counts <- journals$errors
library(bridgeineq)
data(journals)
journals
load("~/Git_projects/bmult/bridgeineq/data/journals.RData")
journals
a <- rep(1, 8)
b <- rep(1, 8)
counts <- journals$errors
total  <- journals$nr_NHST
factor_levels <- levels(journals$journal)
# restricted hypothesis
Hr1 <- c('JCCP < DP < JPSP')
Hr2 <- c('JAP , PS , JCCP , PLOS , DP , FP , JEPG < JPSP')
Hr3 <- c('JAP < PS < JCCP < PLOS < DP < FP < JEPG < JPSP')
factor_levels
out <- binomBayesInformed(factor_levels, Hr1, a=a, b=b, counts=counts, total=total, niter = 5e3, bf_type = 'LogBFer'); out
out <- binomBayesInformed(factor_levels, Hr2, a=a, b=b, counts=counts, total=total, niter = 5e3, bf_type = 'LogBFer'); out
out <- binomBayesInformed(factor_levels, Hr3, a=a, b=b, counts=counts, total=total, niter = 5e3, bf_type = 'LogBFer'); out
Hr1 <- c('JAP , PS , JCCP , PLOS , DP , FP , JEPG < JPSP')
Hr2 <- c('JCCP < DP < JPSP')
Hr3 <- c('JAP < PS < JCCP < PLOS < DP < FP < JEPG < JPSP')
out <- binomBayesInformed(factor_levels, Hr1, a=a, b=b, counts=counts, total=total, niter = 5e4, bf_type = 'LogBFer'); out
out <- binomBayesInformed(factor_levels, Hr2, a=a, b=b, counts=counts, total=total, niter = 5e4, bf_type = 'LogBFer'); out
out <- binomBayesInformed(factor_levels, Hr3, a=a, b=b, counts=counts, total=total, niter = 5e4, bf_type = 'LogBFer'); out
factor_levels <- c('binom1', 'binom2', 'binom3', 'binom4')
counts        <- c(0, 0, 0, 0)
total         <- c(0, 0, 0, 0)
a             <- c(1, 1, 1, 1)
b             <- c(1, 1, 1, 1)
Hr            <- c('binom1 < binom2 < binom3 < binom4')
out <- binomBayesInformed(factor_levels, Hr, a, b, counts, total, niter = 5e3, bf_type = 'LogBFer', seed=2020)
out
out <- binomBayesInformed(factor_levels, Hr, a, b, counts, total, niter = 5e3, bf_type = 'BFer', seed=2020)
out
counts        <- c(3, 100, 800, 900)
total         <- c(1e3, 1e3, 1e3, 1e3)
out <- binomBayesInformed(factor_levels, Hr, a, b, counts, total, niter = 5e3, bf_type = 'BFer', seed=2020)
out <- binomBayesInformed(factor_levels, Hr, a, b, counts, total, niter = 5e3, bf_type = 'BFer', seed=2020);oout
out
factorial(4)
1/factorial(4)
out <- binomBayesInformed(factor_levels, Hr, a, b, counts, total, niter = 5e4, bf_type = 'BFer', seed=2020);out
counts        <- c(3, 4, 10, 11)
total         <- c(15, 12, 12, 12)
a             <- c(1, 1, 1, 1)
b             <- c(1, 1, 1, 1)
Hr            <- c('binom1 < binom2 < binom3 < binom4')
out <- binomBayesInformed(factor_levels, Hr, a, b, counts, total, niter = 5e4, bf_type = 'BFer', seed=2020);out
