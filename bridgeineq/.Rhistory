prior.samples <- rdirichlet(niter, a_collapsed)
# number of posterior samples in accordance with constraints
proportion_prior_samples <- sum(apply(prior.samples, 1, function(x) x[1] >= x[2]/2 & x[2]/2 >= x[3]))/niter
# proportion posterior samples in accordance with constraints
post.samples <- rdirichlet(niter, a_collapsed + x_collapsed)
# number of posterior samples in accordance with constraints
proportion_posterior_samples <- sum(apply(post.samples, 1, function(x) x[1] >= x[2]/2 & x[2]/2 >= x[3]))/niter
# compute Bayes factor BF_re
logBFre <- log(proportion_posterior_samples / proportion_prior_samples)
logBFre
logBFme <- logBF0e + logBFre
logBFme
lbf.1e
n <- 556
x <- c(315, 101, 108, 32)
a <- c(1, 1, 1, 1)
#H0: p = c(9/16, 3/16, 3/16, 1/16)
#H1: p1 > p2 = p3 > p4
#H2: p1 > p2 > p3 > p4
#BF0E
pc <- c(9/16, 3/16, 3/16, 1/16)
lbf.0e <- sum(x * log(pc)) +
sum(lgamma(a)) - lgamma(sum(a)) +
lgamma(n + sum(a)) - sum(lgamma(x+a))
#BF1E
l.savagedickey <- lgamma(sum(x[2:3] + a[2:3])) - lgamma(x[2] + a[2]) - lgamma(x[3] - a[3]) +
lgamma(a[2]) + lgamma(a[3]) - lgamma(a[2] + a[3]) - (x[2] + x[3]) * log(2)
marg.pr.restr <- sapply(1:1e5, function(i){
g <- rgamma(n = 3, shape = c(a[1], a[4], a[2]+a[3] - 1), rate = 1)
pi <- g / sum(g)
theta1 <- pi[1]
theta2 <- pi[2]
theta <- pi[3] / 2
if(theta1 >= theta & theta >= theta2) {
return(1)
} else {
return(0)
}
})
marg.post.restr <- sapply(1:1e5, function(i){
g <- rgamma(n = 3, shape = c(a[1]+x[1], a[4]+x[4], a[2]+a[3]+-1+x[2]+x[3]), rate = 1)
pi <- g / sum(g)
theta1 <- pi[1]
theta2 <- pi[2]
theta <- pi[3] / 2
if(theta1 >= theta & theta >= theta2) {
return(1)
} else {
return(0)
}
})
lbf.restr <- log(mean(marg.post.restr)) - log(mean(marg.pr.restr))
lbf.1e <- l.savagedickey + lbf.restr
lbf.restr
l.savagedickey
lbf.1e
logBFme
exp(logBF0e)
sum(x * log(pc)) +
sum(lgamma(a)) - lgamma(sum(a)) +
lgamma(n + sum(a)) - sum(lgamma(x+a))
#BF0E
# expected counts under the null hypothesis (Binomial median)
counts <- c(101, 108)
alphas <- c(1, 1)
thetas <- c(0.5, 0.5)
expected <- sum(counts)*thetas
expected
# compute Bayes factor
lbeta.xa <- sum(lgamma(alphas + counts)) - lgamma(sum(alphas + counts))
lbeta.a  <- sum(lgamma(alphas)) - lgamma(sum(alphas))
logBFe0 <- (lbeta.xa-lbeta.a) + (0 - sum(counts * log(thetas)))
logBFe0
logBF0e <- -logBFe0
exp(logBF0e)
logBFre
exp(logBFre)
logBFme
logBFme <- logBF0e + logBFre
#########################################################
# Computes Bayes factor for the mixed constraints
#
# Data based on Example I in Robertson (1978)
# Robertson, T. (1978). Testing for and against an order
# restriction on multinomial parameters. Journal of the
# American Statistical Association, 73(361), 197-202.
#
# Code by Alexandra Sarafoglou
# Last modified by Alexandra Sarafoglou, July 2020
#########################################################
rm(list=ls())
####################################
## 0. Load Packages and Functions ##
####################################
library(gtools)
#BF0E
# expected counts under the null hypothesis (Binomial median)
counts <- c(101, 108)
alphas <- c(1, 1)
thetas <- c(0.5, 0.5)
expected <- sum(counts)*thetas
# compute Bayes factor
lbeta.xa <- sum(lgamma(alphas + counts)) - lgamma(sum(alphas + counts))
lbeta.a  <- sum(lgamma(alphas)) - lgamma(sum(alphas))
logBFe0 <- (lbeta.xa-lbeta.a) + (0 - sum(counts * log(thetas)))
logBF0e <- -logBFe0
exp(logBF0e)
#######################
## 1. Mulder example ##
#######################
options      <- list(bayesFactorType = 'BF01')
factorLevels <- paste('g', 1:4, sep='')
niter        <- 1e5
# Analysis
set.seed(4491)
# Analysis H_r
n <- 556
x <- c(315, 101, 108, 32)
a <- c(1, 1, 1, 1)
# initialize parameters
a_collapsed  <-c(a[1], sum(a[2:3]) - 1, a[4])
x_collapsed  <-c(x[1], sum(x[2:3]), x[4])
# proportion prior samples in accordance with constraints
prior.samples <- rdirichlet(niter, a_collapsed)
# number of posterior samples in accordance with constraints
proportion_prior_samples <- sum(apply(prior.samples, 1, function(x) x[1] >= x[2]/2 & x[2]/2 >= x[3]))/niter
# proportion posterior samples in accordance with constraints
post.samples <- rdirichlet(niter, a_collapsed + x_collapsed)
# number of posterior samples in accordance with constraints
proportion_posterior_samples <- sum(apply(post.samples, 1, function(x) x[1] >= x[2]/2 & x[2]/2 >= x[3]))/niter
# compute Bayes factor BF_re
logBFre <- log(proportion_posterior_samples / proportion_prior_samples)
logBFme <- logBF0e + logBFre
exp(logBFme)
70 * (0.6, .65, .7, .75, .72)
70 * c(0.6, .65, .7, .75, .72)
33 * c(.2, .25, .30, .35)
33 * c(.55, .60, .65, .70, .75)
36 * c(0.25, 30, 35, 40)
36 * c(0.25, .30, .35, .40)
38 * c(0.55, .60, .65, .70)
40 * c(0.75, .60, .65, .70)
38 * c(0.55, .60, .65, .70, .75)
55 * c(.6, .65, .7, .74, .77)
40 * c(.45, .5, .55, .6)
40 * c(.45, .5, .55, .6)
40 * c(.55, .6, .65, .69, .73, .77)
50 .,8
50 .8
50 * .8
?chisq.test
install.packages('knitr')
install.packages("knitr")
?knitr::include_graphics
1 - 0.33 - 0.33
1 - 0.33 - 0.33 - 0.1
1 - 0.3 - 0.2 - 0.1
0.9/3
1 - 0.3 - 0.3 - 0.1
1 - 0.1 - 0.3
(1 - 0.1 - 0.3)/2
0.1 - 0.35 - 0.2
1 - 0.1 - 0.35 - 0.2
1 - 0.1 - 0.35 - 0.15
(1 - 0.1 - 0.35)/2
(1 - 0.1 - 0.35 - 0.275)
0.35 - 0.275
(1 - 0.1 - 0.35)/2
(1 - 0.1 - 0.35 - 0.275)
(0.35 - 0.275)
1 - 0.35 - 0.2
1 - 0.35 - 0.2 - 0.1
1 - 0.34 - 0.2 - 0.1
0.275*2
1/4
3*(1/4)
0.45 + 0.2
0.15 + 0.15 + 0.15 + 0.25
1/5
1/5 * 3
0.45
1 - 0.45
1 - 0.45 / 2
(1 - 0.45) / 2
1 - 0.25 - 0.2
1 - 0.35 - 0.2
1 - 0.35 - 0.2 - 0.1
?sample
sample(1:3, 1)
# Create the R package "bridgeineq"
setwd("~/Dropbox/Projects/Multinomial Project/R/bridgeineq")
library(devtools)
library(roxygen2)
library(testthat)
# devtools::create("bridgeineq")
# devtools::use_rcpp()
devtools::document()
devtools::install()
a             <- c(1, 1, 1, 1, 1)
counts        <- c(0, 0, 0, 0, 0)
factor_levels <- paste0('g', 1:5, collapse='')
Hr            <- c('g1 < g2 = g3 = g4 < g5')
output_total  <- multBayesInformed(factor_levels, Hr, a, counts,  niter=5e3, bf_type = 'BFre', seed = 4)
factor_levels
factor_levels <- paste('g', 1:5, collapse='')
factor_levels
paste0('g', 1:5)
factor_levels <- paste0('g', 1:5)
Hr            <- c('g1 < g2 = g3 = g4 < g5')
output_total  <- multBayesInformed(factor_levels, Hr, a, counts,  niter=5e3, bf_type = 'BFre', seed = 4)
output_total$bf_list$bf
testthat::make_expectation(output_total$bf_list$bf)
devtools::test()
devtools::install()
# testthat
devtools::test()
test_that("yields equal Bayes factor output for Haberman example", {
data(lifestresses)
a             <- rep(1, 18)
counts        <- lifestresses$stress.freq
factor_levels <- lifestresses$month
Hr            <- paste0(1:18, collapse=">")
output_total  <- multBayesInformed(factor_levels, Hr, a, counts,  niter=5e3, bf_type = 'BFre', seed = 4)
expect_equal(bayes_factor(output_total),
list(
bf_table = structure(
list(
bf_type = structure(
c(3L, 1L, 2L),
.Label = c("BFer", "BFre",
"LogBFer"),
class = "factor"
),
bf_total = c(-5.14219588563597,
0.00584484100893979, 171.091052514599),
bf_inequalities = c(-5.14219588563597,
0.00584484100893979, 171.091052514599)
),
row.names = c(NA,-3L),
class = "data.frame"
),
bf_ineq_table = structure(
list(
hyp = structure(1L, .Label = "1 > 2 > 3 > 4 > 5 > 6 > 7 > 8 > 9 > 10 > 11 > 12 > 13 > 14 > 15 > 16 > 17 > 18", class = "factor"),
logBFe_inequalities = -5.14219588563597,
logml_prior = -36.3954452080331,
logml_post = -31.2532493223971
),
class = "data.frame",
row.names = c(NA,-1L)
)
))
})
test_that("yields equal Bayes factor output for Mendelian Peas example", {
data(peas)
a             <- c(1, 1, 1, 1)
counts        <- peas$counts
factor_levels <- levels(peas$peas)
Hr            <- c('roundYellow > wrinkledYellow = roundGreen > wrinkledGreen')
output_total  <- multBayesInformed(factor_levels, Hr, a, counts,  niter=5e3, bf_type = 'BFre', seed = 4)
expect_equal(bayes_factor(output_total),
list(
bf_table = structure(
list(
bf_type = structure(
c(3L, 1L, 2L),
.Label = c("BFer", "BFre",
"LogBFer"),
class = "factor"
),
bf_total = c(-4.07162056514532,
0.0170497358993748, 58.6519348981041),
bf_equalities = c(-2.33226548597986,
0.0970755744318043, 10.3012524608083),
bf_inequalities = c(-1.73935507916546,
0.175633633889566, 5.69367027177025)
),
row.names = c(NA,-3L),
class = "data.frame"
),
bf_ineq_table = structure(
list(
hyp = structure(1L, .Label = "roundYellow > wrinkledYellow = roundGreen > wrinkledGreen", class = "factor"),
logBFe_inequalities = -1.73935507916546,
logml_prior = -1.79187528451288,
logml_post = -0.0525202053474192
),
class = "data.frame",
row.names = c(NA,-1L)
)
))
})
test_that("yields equal Bayes factor output for costraints with free parameters", {
data(peas)
a             <- c(1, 1, 1, 1)
counts        <- peas$counts
factor_levels <- levels(peas$peas)
Hr           <- c('roundYellow > wrinkledYellow , roundGreen > wrinkledGreen')
output_total <- multBayesInformed(factor_levels, Hr, a, counts,  niter=5e3, bf_type = 'BFre', seed = 4)
expect_equal(bayes_factor(output_total),
list(
bf_table = structure(
list(
bf_type = structure(
c(3L, 1L, 2L),
.Label = c("BFer", "BFre",
"LogBFer"),
class = "factor"
),
bf_total = c(-2.40735611810453,
0.0900530697897938, 11.1045631463119),
bf_inequalities = c(-2.40735611810453,
0.0900530697897938, 11.1045631463119)
),
row.names = c(NA,-3L),
class = "data.frame"
),
bf_ineq_table = structure(
list(
hyp = structure(1L, .Label = "roundYellow > wrinkledYellow , roundGreen > wrinkledGreen", class = "factor"),
logBFe_inequalities = -2.40735611810453,
logml_prior = -2.48180647354589,
logml_post = -0.0744503554413648
),
class = "data.frame",
row.names = c(NA,-1L)
)
))
})
test_that("tests S3 methods for example with multiple equality and inequality constraints", {
data(lifestresses)
a             <- rep(1, 18)
counts        <- lifestresses$stress.freq
factor_levels <- lifestresses$month
Hr            <- c('1 < 2 & 5 < 3 < 4 < 8 & 10 = 11 = 12 & 13 = 14 = 15 < 16')
output_total  <- multBayesInformed(factor_levels, Hr, a, counts,  niter=5e3, bf_type = 'BFre', seed = 4)
expect_equal(bayes_factor(output_total),
list(
bf_table = structure(
list(
bf_type = structure(
c(3L, 1L, 2L),
.Label = c("BFer", "BFre", "LogBFer"),
class = "factor"
),
bf_total = c(2.58119285238096,13.2128897901512, 0.0756836707095968),
bf_eq_1 = c(-1.03504256068524, 0.355211262568491, 2.81522605102416),
bf_eq_2 = c(-2.20127503702833, 0.110661970261721, 9.03652806501591),
bf_ineq_1 = c(0.816349968384871, 2.2622275475873, 0.442042181418272),
bf_ineq_2 = c(5.03993011644694, 154.459220489584, 0.00647420074263186),
bf_ineq_3 = c(-0.0387696347372691, 0.961972288622288, 1.03953098423674)
),
class = "data.frame",
row.names = c(NA,-3L)
),
bf_ineq_table = structure(
list(
hyp = structure(
3:1,
.Label = c("& 13 = 14 = 15 < 16",
"& 5 < 3 < 4 < 8", "1 < 2"),
class = "factor"
),
logBFe_inequalities = c(0.816349968384871, 5.03993011644694,-0.0387696347372691),
logml_prior = c(-0.693147180559945,-3.17805383034795,-0.287587820248094),
logml_post = c(-1.50949714894482,-8.21798394679488,-0.248818185510824)
),
class = "data.frame",
row.names = c(NA,-3L)
)
))
})
# testthat
devtools::test()
# devtools::create("bridgeineq")
# devtools::use_rcpp()
devtools::document()
devtools::install()
testthat::test_check('bridgeineq')
testthat::test_check()
testthat::test_check('bridgeineq')
test_check('bridgeineq')
library(testthat)
test_check('bridgeineq')
install.packages('covatest')
browseVignettes("covatest")
browseVignettes("bridgesampling")
browseVignettes("ROI")
browseVignettes("mgm")
install.packages("mgm")
browseVignettes("mgm")
data(lifestresses)
lifestresses
# visualize the data
op <- par(cex.main = 1.5, mar = c(5, 6, 4, 5) + 0.1, mgp = c(3.5, 1, 0), cex.lab = 1.5 , font.lab = 2, cex.axis = 1.3, bty = "n", las = 1)
plot(lifestresses$month, lifestresses$stress.freq, col = "black",
pch = 1, cex = 2, type="b",
xlim = c(0, 18), ylim = c(0, 20),
ylab = "", xlab = "", axes = FALSE)
axis(1, at = seq(0, 18, length.out = 10), label = seq(0, 18, length.out = 10))
op <- par(cex.main = 1.5, mar = c(5, 6, 4, 5) + 0.1, mgp = c(3.5, 1, 0), cex.lab = 1.5 , font.lab = 2, cex.axis = 1.3, bty = "n", las = 1)
plot(lifestresses$month, lifestresses$stress.freq, col = "black",
pch = 1, cex = 2, type="b",
xlim = c(0, 18), ylim = c(0, 20),
ylab = "", xlab = "", axes = FALSE)
axis(1, at = seq(0, 18, length.out = 10), label = seq(0, 18, length.out = 10))
axis(2, at = seq(0, 20, length.out = 5), label = seq(0, 20, length.out = 5), las = 1)
par(las = 0)
mtext("Months Before Interview", side = 1, line = 2.5, cex = 1.5)
mtext("Participants Reporting a\nNegative Life Event", side = 2, line = 3.0, cex = 1.5)
data(lifestresses)
lifestresses
categories <- lifestresses$month
x          <- lifestresses$stress.freq
categories
x
# Prior specification
# We assign a uniform Dirichlet distribution, that is, we set all concentration parameters to 1
alpha <- rep(1, 18)
# Test the following restricted Hypothesis:
# Hr: month1 > month2 > ... > month18
Hr   <- paste0(1:18, collapse=">"); Hr
out  <- multBayesInformed(categories, x, alpha, Hr, seed = 2020)
x
out  <- multBayesInformed(categories, data=x, alpha=alpha, Hr=Hr, seed = 2020)
out  <- multBayesInformed(categories, data=x, a=alpha, Hr=Hr, seed = 2020)
out <- multBayesInformed(categories, Hr=Hr, a=alpha, counts = x, seed = 2020)
out
summary(out)
bayes_factor(out)
bayesfactor(out)
bayes_factor(out)
out$bf_list
str(out)
out$bf_list$bf
out$bf_list
bridge_output(out)
summary(bridge_output(out))
summary(bridge_output(out))
bridge_output(out)
error_measures(bridge_output(out))
eq_results <- multBayesBfEquality(alphas=alpha, counts=x)
eq_results
alpha
eq_results$bf
out$bf_list$bf
eq_results
## Build vignettes
devtools::build_vignettes()
data(lifestresses)
lifestresses
# visualize the data
op <- par(cex.main = 1.5, mar = c(5, 6, 4, 5) + 0.1, mgp = c(3.5, 1, 0), cex.lab = 1.5 , font.lab = 2, cex.axis = 1.3, bty = "n", las = 1)
plot(lifestresses$month, lifestresses$stress.freq, col = "black",
pch = 1, cex = 2, type="b",
xlim = c(0, 18), ylim = c(0, 20),
ylab = "", xlab = "", axes = FALSE)
categories <- lifestresses$month
x          <- lifestresses$stress.freq
# Prior specification
# We assign a uniform Dirichlet distribution, that is, we set all concentration parameters to 1
alpha <- rep(1, 18)
# Test the following restricted Hypothesis:
# Hr: month1 > month2 > ... > month18
Hr   <- paste0(1:18, collapse=">"); Hr
ineq_results <- multBayesInformed(categories, Hr=Hr, a=alpha, counts=x, seed = 2020)
ineq_results <- multBayesInformed(categories, Hr=Hr, a=alpha, counts=x, bf_type = 'BFre', seed = 2020)
summary(ineq_results)
ineq_results$bf_list
ineq_results$bf_list
ineq_bayesfactors <- ineq_results$bf_list$bf
ineq_bayesfactors
eq_results      <- multBayesBfEquality(a=alpha, counts=x)
eq_bayesfactors <- eq_results$bf
eq_bayesfactors
BFr0 <- ineq_bayesfactors['BFre'] * eq_bayesfactors['BFe0']; BFr0
ineq_bayesfactors['BFre']
eq_bayesfactors['BFe0']
ineq_bayesfactors['BFre'] * eq_bayesfactors['BFe0']
ineq_bayesfactors[['BFre']] * eq_bayesfactors[['BFe0']]
BFr0 <- ineq_bayesfactors[['BFre']] * eq_bayesfactors[['BFe0']]; BFr0
BFr0
ineq_bayesfactors[['BFre']]
eq_bayesfactors[['BFe0']]
data(peas)
peas
peas$peas
categories <- peas$peas
x          <- peas$counts
# Prior specification
# We assign a uniform Dirichlet distribution, that is, we set all concentration parameters to 1
alpha <- c(1, 1, 1, 1)
# Test the following restricted Hypothesis:
# Hr: month1 > month2 > ... > month18
Hr   <- c('roundYellow > wrinkledYellow = roundGreen > wrinkledGreen')
ineq_results <- multBayesInformed(categories, Hr=Hr, a=alpha, counts=x, bf_type = 'BFre', seed = 2020)
summary(ineq_results)
summary(ineq_results)$bf
summary(ineq_results)
ineq_results$bf_list$bf
ineq_results$bf_list$logBFe_equalities
exp(ineq_results$bf_list$logBFe_equalities)
1/exp(ineq_results$bf_list$logBFe_equalities)
ineq_results$bf_list$logBFe_inequalities
ineq_results$bf_list$logBFe_inequalities[1]
exp(ineq_results$bf_list$logBFe_inequalities[1])
1/exp(ineq_results$bf_list$logBFe_inequalities[1])
ineq_results$bf_list
attributes(ineq_results)
attributes(summary(ineq_results))
summary(ineq_results)$equalities
summary(ineq_results)$equalities$bf
